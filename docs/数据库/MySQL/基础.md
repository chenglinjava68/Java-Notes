## 关于count

#### 实现方式

* MyISAM的实现方式是把一个表的总行数存在了磁盘，因此执行count(*)的时候会直接返回这个数，效率很高
* InnoDB则是需要把数据一行一行地从引擎里面读出来，然后累计行数

InnoDB为什么不跟MyISAM的实现一样呢？**因为多版本并发控制MVCC的原因，即一个记录存在多个版本**。

#### 不同的count用法

count()的语义：count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是null，累计值就加1，否则不加，最后返回累计值。

count(*)、count(1)、count(主键id)都表示返回满足条件的结果集的总行数；而count(字段)则返回满足条件的数据行里面参数不为NULL的字段。

**对于count(主键id)来说**，InnoDB引擎会遍历整张表，把每一行的id值取出来，返回给server层，server层拿到id后，判断是不可能为空的，就按行累加。

**对于count(1)来说**，InnoDB遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，就按行累加。

从这里看出，count(1)执行得要比count(主键id)快，因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。

**对于count(字段)来说**：

* 如果这个字段是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加
* 如果这个字段定义允许为null，那么执行的时候，判断到有可能是null，那么还要把值取出来再判断下，不是null再累加

**但是count(*)是例外**，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。

**结论**：按照效率排序的话：count(字段)<count(主键id)<count(1)≈count(*)