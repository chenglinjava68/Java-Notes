#### 事务的隔离级别

* 读未提交

  一个事务还没有提交时，它所做的更改就能被其它事务所看到

* 读已提交

  一个事务提交后，所做的更改才能被其它事务所看到

* 可重复读

  一个事务在执行过程中所看到的数据，总是和它在启动时所看到的数据是一致的。在这种隔离级别下，未提交的变更也是不能被其它事务所看到的。**可重复读的核心就是一致性读（consistent read）**

* 串行化

  隔离的最高级别，对同一行记录，读会加读锁，写会加写锁。当出现读写冲突的时候，后访问的事务必须等到前一个事务执行完成，才能继续执行。

在实现上，数据库里面会创建一个视图（**这里说的视图是InnoDB在实现MVCC时用到的一致性视图**），访问的时候以视图的逻辑结果为准。**在“可重复读”隔离级别下，这个视图（read-view）是在事务启动时创建的，整个事务存在期间都在用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。而“读未提交”级别下直接返回记录上的最新值（也就是读取最新的数据行，要求很低，无需使用MVCC），没有视图概念。“串行化”则通过加锁的方式避免并行访问**。

#### 事务的隔离实现

以“可重复读”为。在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，可以通过回滚操作，得到前一个状态的值。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类型下面的记录

![](https://z3.ax1x.com/2021/07/12/WPfLSU.png)

可以发现，同一条记录，存在不同的多个版本，这就是多版本并发控制（MVCC)。对于视图A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。

回滚日志不能一直保留，否则会占用很大的内存。

**那什么时候删除呢？当没有事务再需要用到这些回滚日志时**

**什么时候才不需要？当系统里没有比这个回滚日志更早的read-view的时候**

#### 长事务

也就是长时间没有提交的事务，意味着系统里面存在着很老的事务视图，它会导致如下问题

* 大量占用存储空间：长事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚日志都需要保留
* 还会占用锁资源，拖垮整个库

事务的启动方式有2种

1、显示启动事务语句，begin或start transaction，配套的提交语句是commit，回滚语句是rollback

2、set autocommit=0，关闭自动提交

怎么避免长事务？使用`set autocommit=1`，通过显示语句的方式来启动事务。 如果是`set autocommit=0`，会导致接下来的查询都在事务中，如果是长连接，就会导致意外的长事务。

#### 事务的启动时机

`begin/start transaction`命令并不是一个事务的的起点（此时查看事务表是空的），在执行到它们之后的第一个操作InnoDB表的语句（增删改查），事务才真正启动（此时可通过`information_schema.innodb.trx`查看）。如果想马上启动一个事务，可以使用`start transaction with consistent snapshot`命令，这个命令代表从这行语句开始创建一个持续整个事务的一致性快照。

#### MVCC

基本思想：MVCC利用记录的多版本性质，写操作更新最新的版本快照（当前读），读操作去读旧的版本快照，没有互斥关系。在MVCC中，事务的修改操作会为数据行新增一个版本快照。

脏读和不可重复读的根本原因是读取到了其他事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读的问题，MVCC规定只能读取已经提交了的快照（MVCC不能解决幻读问题，这个后面会说）。当然一个事务可以读取自身未提交的事务，这不算脏读。

mysql中的两个视图：

* 一个是view。用查询定义的虚拟表
* 另一个是InnoDB实现MVCC时用到的一致性视图，即consistent read view，**用于支持RC（读提交）和RR（可重复读）隔离级别的实现**。

InnoDB里面每个事务都有一个事务ID，叫做transaction id。在事务开始的时候向InnoDB事务系统申请，按**申请顺序严格递增**。

并且每行数据也是有多个版本的，每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

下图是一个记录被多个事务连续更新后的状态

![](https://z3.ax1x.com/2021/07/12/WidzrT.png)

其中语句更新生成的回滚日志`undo log`就是上图的u1,u2,u3，存储的多个版本的快照，这些日志通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来。

按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这 个事务执行期间，其他事务的更新对它不可见。在实现上，InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务id，活跃是指事务**启动了但是还没提交**。

![](https://z3.ax1x.com/2021/07/12/Witu6S.png)

最小值可以记为低水位，当前系统中已创建的事务ID的最大值+1记为高水位，这个视图和高水位，就组成了当前事务的一致性视图，这个视图数组把所有的trx_id分成了几种不同的情况

![](https://z3.ax1x.com/2021/07/12/WiylFS.png)

现在有一个表，初始化语句如下：

~~~mysql
mysql> CREATE TABLE `t` (
`id` int(11) NOT NULL,
`k` int(11) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
~~~

分别开启三个窗口，有如下表3个事务

| 事务A                                      | 事务B                                                        | 事务C                         |
| :----------------------------------------- | ------------------------------------------------------------ | ----------------------------- |
| start transaction with consistent snapshot |                                                              |                               |
|                                            | start transaction with consistent snapshot                   |                               |
|                                            |                                                              | update t set k=k+1 where id=1 |
|                                            | update t set k=k+1 where id=1;select k from t where       id =1 |                               |
| select k from t where id=1;commit          |                                                              |                               |
|                                            | commit;                                                      |                               |

##### 读逻辑

事务C没有显示开启事务，说明它本身就是一个事务，语句完成时会自动提交。事务A查询数据逻辑图如下

![](https://z3.ax1x.com/2021/07/12/Wi0H9s.png)

当事务A要查询数据的时候，它的视图数组是[99,100]，读数据流程如下；

* 找到(1,3)的时候，判断出row trx_id=101，比高水位大，处于红色区域，不可见
* 接着找到上一个版本，row trx_id=102，比高水位大，处于红色区域，不可见
* 继续往上找，row trx_id=90，比低水位小，处于绿色区域，可见 

也就是说，事务A不论在什么时候查询，看到这行数据的结果都是一致的，这叫**一致性读**，也叫**快照读**。

总结下，就是：一个数据版本，对于一个事务视图来说，**除了自己的更新总是可见以外**，有三种情况：

* 版本未提交，不可见

* 版本已提交，但是在视图创建之后提交的，不可见

* 版本已提交，而且是在视图创建之前提交的，可见

利用这个结论，再分析事务A查询的过程，由于事务A的查询语句的视图数组是在事务A启动的时候生成的，此时：

* (1,3)还没提交，属于情况1，不可见
* (1,2)已提交，但是在A视图创建之后提交的，不可见
* (1,1)是在视图创建之前提交的，可见

##### 更新逻辑

我们按上面的逻辑分析事务B中的更新语句，由于（1,2）是在B视图创建之后才提交的，按理来说应该是看不见的，也就不会算出（1,3）来。那是什么原因呢？

当B事务执行更新语句时，**它不能在历史版本上更新，否则就会导致事务C的更新丢失**，因此，事务B只能在当前版本进行更新。这里用到了一条规则：**更新数据都是先读后写的，这个读，只能读当前值，所以也叫当前读**。

##### 一致性读和当前读

一致性读前面说了，SELECT操作就是操作快照中的数据，不需要加锁。

而当MVCC对数据进行修改（update，insert，delete）需要进行加锁，从而读取最新数据。MVCC并不是完全不用加锁，而只是避免了SELECT的加锁操作。

当然，在进行SELECT操作时，我们也可以强制指定进行加锁操作，比如加读锁和写锁

~~~mysql
SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;
~~~



#### 总结

InnoDB中的行数据有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图。对于查询语句是一致性读，一致性读会根据row trx_id和一致性视图（read-view）来确定数据版本的可见性。而对于修改语句则是当前读，总是读取已经提交的最新

版本。