根据加锁的范围，可以分为**全局锁**，**表级锁**，**行锁**。

## 全局锁

使用做全库逻辑备份的场景。

如果引擎不支持事务，那么建议使用FTWRL命令，而对于InnoDB引擎，建议使用官方自带的备份工具mysqldump，使用参数-single-transaction来拿到一致性视图，确保这个过程可以正常更新数据。

## 表级锁

#### 表锁

加锁：lock tables xxx read/write

释放锁：unlock tables

对应InnoDB，建议使用行锁，毕竟锁住整个表影响太大

#### MDL

MDL是元数据锁（meta data lock）。

加锁是访问一张表的时候系统自动加上的，而**释放锁是事务提交的时候才会释放**。所以在一个长事务中，可能会导致锁住线上查询和更新语句。

所以引出一个问题：**如何安全的给小表加字段？**

1、解决长事务：事务不提交，MDL锁不会释放，可以查看information_schema.innodb_trx表，如果发现长事务，先暂停DDL，在kill掉这个长事务

2、如果变更的表是一个热点表，请求很频繁，这时候Kill可能未必管用，因为新的请求马上就来了。理想情况：在alter table语句里面设定等待时间，如果在这 期间能够拿到MDL写锁最好，如果拿不到，也不要阻塞后面的业务语句，先放弃。然后通过重试命令重试

~~~mysql
ALTER TABLE tbl_name WAIT N add column ...
ALTER TABLE tbl_name NOWAIT add column ...
~~~

## 行锁

**两阶段锁协议**：

加锁：需要的时候加

释放锁：并不是不需要就释放锁，而是等整个事务结束才释放锁

由这个协议，可以对我们使用事务带来帮助：**如果事务中需要锁多个行，要把最可能发生锁冲突、最可能影响并发度的锁尽量往后放**。

举个例子：

现在有一个顾客A要在影院B购买电影票，涉及的操作如下：

1、从顾客A从账户中扣除电影票价

2、给影院B的账户余额加上电影票价

3、记录一条交易日志

为了保证交易的原子性，这3个操作在同一个事务中进行。如果现在有另外一个用户B需要在影院B购买电影票，那么这两个事务冲突的部分就是语句2了。由于两阶段协议，无论怎么安排语句的顺序，所有操作需要的行锁都是要在事务提交的时候才释放。所以，可以将语句2的顺序放在最后，比如3、1、2这样的顺序，那么影院账号余额这一行的锁时间就最少。这样就最大程度的 减少了事务之间的锁等待，提升了并发度。

但如果现在影院搞活动，可以低价预售一年内的所有电影票，而且这个活动只做一天，那么会出现什么情况呢？比如用户A购买了a这张电影票，需要给影院B的余额加上a的票价，用户B购买了b这张电影票，需要给影院B的余额加上b的票价。如果这个时候用户A要购买b这张电影票，准备给影院B的余额加上b票价的时候就会被锁住，对于用户B购买电影票a来说也是一样，也就是说，这个时候发生了**死锁**。就会导致MySQL挂掉，表现形式就是CPU利用率很高，但是执行的事务却很少。

**死锁检测**

发生了死锁，那么就要对死锁进行检测，有2种方式

1、进入等待，直到超时时间

2、发现死锁，回滚死锁链中的某一个事务

第一种方式，超时时间设置太大太小都不好，所以正常情况都是采用第二种。但是这样也会有额外的负担，比如每个新来的被堵住的线程，都要判断会不会由于自己的加入而导致死锁，时间复杂度为O(N)。

所以说，**死锁检测会耗费大量的CPU资源**。怎么解决由热点行更新导致的性能问题？

1、临时把死锁检测关掉，风险太大

2、控制并发度。

​	但是不能在客户端控制，因为会出现客户端很多的情况，比如600个客户端，即使每个客户端控制到只有5个并发线程，汇总到服务端后，峰值并发数也有3000。

​	所以需要在客户端控制，**基本思路：进入引擎之前排队，这样在innoDB内部就不会有大量的死锁检测工作了**。当然，也可以将一行改成逻辑上的多行，比如影院余额放在10个记录上，这样冲突概率就变成了原来的1/10。但是，这种做法就需要考虑当用户退款，一部分行记录变成0的时候，代码要有特殊处理。所以这种做法需要根据业务做详细设计。

#### 间隙锁

间隙锁（gap lock）是为了解决幻读引入的。**它锁的是两个值之间的空隙。间隙锁之间不存在冲突关系。跟间隙锁存在冲突 关系的，是“往在这个间隙中插入一个记录”这个操作**。

需要注意的是，间隙锁在**可重复读隔离级别下才有效**，并且使用间隙锁会出现**死锁**的情况！！！

加锁范围：两边都是开区间 (  )

#### next-key lock

行锁+间隙锁

前开后闭区间：(  ]