40题：K个最小的数、59题：滑动窗口的最大值

两题的解题思路是一样的：都是维护一个堆，一个是大小为K的堆，一个是大小为滑动窗口大小的堆

总结：看到题目有最小、最大等字眼，并且还带有大小的，应该首先想到堆，堆的大小就是题目中提到的大小

#### 递归

递归问题首先要明确这个递归函数的意义，然后要定义合适的base case防止栈溢出。

可以总结成下面2个结论

**1、基本上递归问题都可以用函数表示**

比如斐波那契数列，f(n)=f(n-1)+f(n-2)

关于这个函数，我们可以表示为f(n)和f(n-1)的关系，然后求出f(n-1)

**2、递归是关于某个重复动作的描述**

如果一个问题A可以分解为若干子问题B、C、D，可以假设子问题都已经解决，在此基础上思考如何解决问题A，而且，只需要思考问题A和子问题B、C、D这两层之间的关系，不需要再思考子问题与子子问题、子子问题与子子子问题之间的关系，否则就会跳入递归中，而我们的脑袋是压不了几个栈的。**也就是说，递归只用考虑当前层和下一层的关系，不能继续往下深入**。

比如删除链表的倒数第K个节点这道题，我们分析下这个过程：

令f(head)为问题：反转以head为头节点的链表。

一般我们需要考虑f(n)和f(n-1)的关系，那么n就代表以head为头节点的单向链表，而n-1就代表以head.next为头节点的单向链表。所以，令f(head.next)为问题：反转以head.next为头节点的单链表。

那么，就要寻找f(head)和f(head.next)之间的关系，以下面这个链表为例

~~~
1->2->3
~~~

f(1)=f(2)+?

可以假设子问题f(2)已经解决，那么如何解决f(1)?

只要反转这两个节点，即head.next.next=head即可，同时head.next=null。

#### 二叉树

此类问题，关键是将题目的要求细化（每个节点应该干什么），首先要搞清楚根节点应该做什么，然后剩下的事情交给前/中/后序遍历框架即可。

##### 中序遍历

中序遍历能保证遍历后的二叉树是有序的

~~~java
//左、根、右
void dfs(TreeNode root) {
    if(root == null) return;
    dfs(root.left); // 左
    System.out.println(root.val); // 根
    dfs(root.right); // 右
}
~~~

如果要让遍历后的结果是倒序的，那么只需调换位置即可

~~~java
//倒序为：右、根、左
void dfs(TreeNode root) {
    if(root == null) return;
    dfs(root.right); // 右
    System.out.println(root.val); // 根
    dfs(root.left); // 左
}
~~~

#### 动态规划

利用历史记录，来避免重复计算，而这些历史记录，需要一些变量来保存，一般用一维数组或者二维数组。

步骤

**1、定义数组元素的含义**

比如定义数组dp[]，那么这个数组的含义是什么呢？比如dp[i]代表什么？

**题目求什么，就定义什么**。注意子序列问题的定义比较特殊

**2、找出数组元素之间的关系式（状态转移方程）**

比如计算dp[n]，可以利用dp[n-1]，dp[n-2]...dp[1]来推出dp[n]，也就是利用**历史数据**来推出新的元素值。比如dp[n]=dp[n-1]+dp[n-2]

数学归纳法，知道了dp[i-1]怎么求出dp[i]来？只有将dp[i-1]和dp[i]建立起联系，才能通过数学归纳法写出状态转移方程。

**3、找出初始值（base case）**

**如何列出状态转移方程**：

1、确定base case

2、确定状态：原问题和子问题中会变化的变量

3、确定选择：也就是导致状态产生变化的行为

4、明确dp数组/函数的定义、

一般，动态规划有以下几种分类：

1. 最值型动态规划，比如求最大，最小值是多少
2. 计数型动态规划，比如换硬币，有多少种换法
3. 坐标型动态规划，比如在m*n矩阵求最值型，计数型，一般是二维矩阵
4. 区间型动态规划，比如在区间中求最值

#### 回溯

实质上是一个决策树的遍历过程。需考虑3个问题

1、路径：也就是做出的选择（已经做过的）

2、选择列表：当前可以做出的选择

3、结束条件：到达决策树底层，无法再做选择的条件

框架：

~~~python
result=[]
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        #做选择
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
        #撤销选择
        路径.remove(选择)
~~~

#### 重复问题

1、二叉树中的重复问题

比如判断一棵树是否是平衡二叉树，如果采用前序遍历，那么就会重复计算每一个节点的高度，那么可以采用后序遍历的方式自底向上计算每个节点的高度

2、动态规划中的重复问题

带备忘录或者自底向上

3、nsum中的重复问题

使用双指针的时候跳过重复的部分

#### 双指针

##### 快慢指针

主要用来解决链表中的问题，比如判断是否有环，求链表的倒数第K个节点等

##### 左右指针

主要用来解决数组或者字符串中的问题，比如二分查找

##### 滑动窗口

主要用来解决子串问题