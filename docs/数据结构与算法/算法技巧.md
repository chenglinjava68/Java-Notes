40题：K个最小的数、59题：滑动窗口的最大值

两题的解题思路是一样的：都是维护一个堆，一个是大小为K的堆，一个是大小为滑动窗口大小的堆

总结：看到题目有最小、最大等字眼，并且还带有大小的，应该首先想到堆，堆的大小就是题目中提到的大小

#### 二叉树

此类问题，关键是将题目的要求细化（每个节点应该干什么），首先要搞清楚根节点应该做什么，然后剩下的事情交给前/中/后序遍历框架即可。

##### 中序遍历

中序遍历能保证遍历后的二叉树是有序的

~~~java
//左、根、右
void dfs(TreeNode root) {
    if(root == null) return;
    dfs(root.left); // 左
    System.out.println(root.val); // 根
    dfs(root.right); // 右
}
~~~

如果要让遍历后的结果是倒序的，那么只需调换位置即可

~~~java
//倒序为：右、根、左
void dfs(TreeNode root) {
    if(root == null) return;
    dfs(root.right); // 右
    System.out.println(root.val); // 根
    dfs(root.left); // 左
}
~~~

#### 动态规划

利用历史记录，来避免重复计算，而这些历史记录，需要一些变量来保存，一般用一维数组或者二维数组。

步骤

**1、定义数组元素的含义**

比如定义数组dp[]，那么这个数组的含义是什么呢？比如dp[i]代表什么？

**题目求什么，就定义什么**。注意子序列问题的定义比较特殊

**2、找出数组元素之间的关系式（状态转移方程）**

比如计算dp[n]，可以利用dp[n-1]，dp[n-2]...dp[1]来推出dp[n]，也就是利用**历史数据**来推出新的元素值。比如dp[n]=dp[n-1]+dp[n-2]

数学归纳法，知道了dp[i-1]怎么求出dp[i]来？只有将dp[i-1]和dp[i]建立起联系，才能通过数学归纳法写出状态转移方程。

**3、找出初始值（base case）**



**如何列出状态转移方程**：

1、确定base case

2、确定状态：原问题和子问题中会变化的变量

3、确定选择：也就是导致状态产生变化的行为

4、明确dp数组/函数的定义、



一般，动态规划有以下几种分类：

1. 最值型动态规划，比如求最大，最小值是多少
2. 计数型动态规划，比如换硬币，有多少种换法
3. 坐标型动态规划，比如在m*n矩阵求最值型，计数型，一般是二维矩阵
4. 区间型动态规划，比如在区间中求最值

#### 回溯

实质上是一个决策树的遍历过程。需考虑3个问题

1、路径：也就是做出的选择（已经做过的）

2、选择列表：当前可以做出的选择

3、结束条件：到达决策树底层，无法再做选择的条件

框架：

~~~python
result=[]
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        #做选择
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
        #撤销选择
        路径.remove(选择)
~~~

#### 重复问题

1、二叉树中的重复问题

比如判断一棵树是否是平衡二叉树，如果采用前序遍历，那么就会重复计算每一个节点的高度，那么可以采用后序遍历的方式自底向上计算每个节点的高度

2、动态规划中的重复问题

带备忘录或者自底向上

3、nsum中的重复问题

使用双指针的时候跳过重复的部分