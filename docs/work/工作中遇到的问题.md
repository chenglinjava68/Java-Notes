## springboot国际化配置

问题：controller层接口中设置的msg是英文，但是想让页面输出中文信息

首先我们在项目中都会自定义一个异常类继承自Exception,方便错误排查

~~~java
@Data
@AllArgsConstructor
@NoArgsConstructor
@RequiredArgsConstructor
@ToString
@Accessors(chain = true)
@EqualsAndHashCode(callSuper=false)
public class BizException extends Exception {
    @NonNull
    private String code;
    @NonNull
    private String errMsg;
    private Object[] params;


    @Override
    public String getMessage() {
        String message = null;
        if (!StringUtils.isEmpty(errMsg)) {
            message = MessageUtils.message(errMsg, params);
        }
        return message;
    }
}
~~~

当我们在逻辑层抛出异常，比如

~~~java
throw new BizException(ResultCode.get(FinalParam.INVALID).getCode(), FinalParam.IS_PACKING, params);
~~~

当在controller中返回信息给前台时，当捕捉到异常时

~~~java
try{
    ...
}catch(Exceptioin e){
    return Response.error(e.getMessage)
}
~~~

这时会调用子类BizException中重写的getMessage()方法。

在该方法中，调用了MessageUtils.message(errMsg, params)方法

~~~java
/**
 * 获取i18n资源文件,i18n就是internationalization的缩写
 *
 * @author lsp
 */
public class MessageUtils {
    private MessageUtils() {

    }

    /**
     * 根据消息键和参数 获取消息 委托给spring messageSource
     *
     * @param code 消息键,messaes.propertis中配置的key
     * @param args 参数
     * @return 获取国际化翻译值
     */
    public static String message(String code, Object... args) {
        MessageSource messageSource = SpringUtils.getBean(MessageSource.class);
        return messageSource.getMessage(code, args, LocaleContextHolder.getLocale());
    }
}
~~~

在 controller 中得到当前请求的Local, 代码可以如下写：

Locale locale = LocaleContextHolder.getLocale();

**getMessage方法中的第三个参数就是指定的国际化资源文件。**

springboot默认就支持国际化的，而且不需要你过多的做什么配置，**只需要在resources/下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。**
messages_zh_CN.properties（中文）
messages_en_US.properties（英文）

假设现在有一个配置文件在resouces目录下的messages目录下名称叫messages.properties

~~~prop
asset_code_is_packing=资产码已装箱,箱号为：{0}
~~~

**其中的占位符表示对getMessages方法中第二个参数args取值，0就代表第一个参数**。比如上面说过逻辑层抛出的异常

~~~java
throw new BizException(ResultCode.get(FinalParam.INVALID).getCode(), FinalParam.IS_PACKING, params);
~~~

那么这时候{0}就是params的值（上面的FinalParam.INVALID就是常量asset_code_is_packing）

这样，controller层的接口就能将设置的英文异常转换为中问异常返回给前端。而常用的页面选择语言也是类似道理。

## JSON文件自定义Response的code和msg

上面在将国际化配置的时候有这样一段异常

~~~java
throw new BizException(ResultCode.get(FinalParam.INVALID).getCode(), FinalParam.IS_PACKING, params);
~~~

其中ResultCode.get(FinalParam.INVALID)就是获取JSON文件配置的code。

看下ResultCode.get方法

~~~java
....
//定义一个map当做缓存使用
private static Map<String, ResultCode> cache = new HashMap<>();

public static ResultCode get(String msg) {
    ResultCode resultCode = cache.get(msg);
    if (resultCode == null) {
        ObjectMapper mapper = new ObjectMapper();
        try {
            Map<String, Object> map = mapper.readValue(config.getInputStream(), Map.class);
            Object o = map.get(msg);
            String code = JSONObject.fromObject(o).getString("code");
            String rtmsg = JSONObject.fromObject(o).getString("msg");
            resultCode = new ResultCode();
            resultCode.setCode(code);
            resultCode.setMessage(rtmsg);
            cache.put(msg, resultCode);
        } catch (Exception e) {
            log.error("代码参数配置JSON文件读取异常", e);
        }
    }
    return resultCode;
}
....
~~~

其中的config属性和配置文件的读取

~~~java
private static Resource config;   
...
@Value("classpath:resp.json")
public void setConfig(Resource config) {
    ResultCode.config = config;
}
~~~

其中的resp.json文件在resources目录下

~~~json
{
  "SUCCESS": {
    "msg": "SUCCESS",
    "code": "COMMON_200"
  },
  "FAIL": {
    "msg": "FAIL",
    "code": "COMMON_400"
  },
  ....
}
~~~

## 非spring环境中获取bean

在国际化配置的时候有这么一行代码

~~~java
MessageSource messageSource = SpringUtils.getBean(MessageSource.class);
~~~

SpringUtils就是方便在非spring管理环境中获取bean的

~~~java
/**
 * spring工具类 方便在非spring管理环境中获取bean
 *
 * @author lsp
 */
@Component
public final class SpringUtils implements BeanFactoryPostProcessor {
    /**
     * Spring应用上下文环境
     */
    private static ConfigurableListableBeanFactory beanFactory;

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        SpringUtils.beanFactory = beanFactory;
    }

    /**
     * 获取对象
     *
     * @param name
     * @return Object 一个以所给名字注册的bean的实例
     * @throws BeansException
     */
    @SuppressWarnings("unchecked")
    public static <T> T getBean(String name) {
        return (T) beanFactory.getBean(name);
    }

    /**
     * 获取类型为requiredType的对象
     *
     * @param clz
     * @return
     * @throws BeansException
     */
    public static <T> T getBean(Class<T> clz) {
        return beanFactory.getBean(clz);
    }

    /**
     * 如果BeanFactory包含一个与所给名称匹配的bean定义，则返回true
     *
     * @param name
     * @return boolean
     */
    public static boolean containsBean(String name) {
        return beanFactory.containsBean(name);
    }

    /**
     * 判断以给定名字注册的bean定义是一个singleton还是一个prototype。 如果与给定名字相应的bean定义没有被找到，将会抛出一个异常（NoSuchBeanDefinitionException）
     *
     * @param name
     * @return boolean
     * @throws NoSuchBeanDefinitionException
     */
    public static boolean isSingleton(String name) {
        return beanFactory.isSingleton(name);
    }

    /**
     * @param name
     * @return Class 注册对象的类型
     * @throws NoSuchBeanDefinitionException
     */
    public static Class<?> getType(String name) {
        return beanFactory.getType(name);
    }

    /**
     * 如果给定的bean名字在bean定义中有别名，则返回这些别名
     *
     * @param name
     * @return
     * @throws NoSuchBeanDefinitionException
     */
    public static String[] getAliases(String name) {
        return beanFactory.getAliases(name);
    }

    /**
     * 获取aop代理对象
     *
     * @param invoker
     * @return
     */
    @SuppressWarnings("unchecked")
    public static <T> T getAopProxy(T invoker) {
        return (T) AopContext.currentProxy();
    }
~~~



