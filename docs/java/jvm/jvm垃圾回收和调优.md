## 垃圾判断算法

#### 引用计数法

在对象中添加⼀个属性⽤于标记对象被引⽤的次数，每多⼀个其他对象引⽤，计数+1，当引⽤失效时，计 数-1，如果计数=0，表示没有其他对象引⽤，就可以被回收。

![](https://z3.ax1x.com/2021/08/22/hSGF56.png)

好处：简单、效率高

坏处：无法解析循环引用的问题

#### 可达性分析法

通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

![](https://z3.ax1x.com/2021/08/22/hSGwaq.png)

可作为 GC Roots 的对象包括下面几种:

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

## 内存池

所有垃圾回收算法都是针对内存池的。

为了避免频繁调用操作系统API去向操作系统申请分配内存、释放内存，引入了内存池的概念。

![](https://z3.ax1x.com/2021/08/22/hSJ1m9.png)

#### Memory Pool

即内存池，JVM中的内存模型管理器

#### Memory Chunk

内存块，比如堆、元空间等

#### Memory Cell

具体的对象占用的空间，一个cell占8字节（8字节对齐），一个对象可以有多个cell

![](https://z3.ax1x.com/2021/08/22/hSJ6tP.png)

## 垃圾回收算法

#### 标记清除

最基础的收集算法，后续收集算法的基础

分两个阶段：

* 标记：标记出所有需要被回收的对象（或标记存活的对象）
* 清除：回收所有被标记的对象（或所有未被标记的对象）

存在问题：

* 效率不稳定：当Java堆中包含大量对象，执行效率会随着对象数量的增长而降低
* 内存碎片化问题：

#### 标记复制

为了解决标记清除的效率问题。将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收

存在问题：如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制开销。

优点：对于多数对象都是可回收的情况，需要复制的就是占少数的存活对象，实现简单、运行高效。所以**很多虚拟机都采用了这种算法来回收新生代**。

缺点：将可用内存缩小为了原来的一半，空间浪费太多

#### 标记整理

根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

* 做了什么？合并内存碎片，让内存回归到连续状态
* 优点：可以合并内存碎片
* 缺点：合并过程是一个CPU密集型的操作，所以会耗费CPU

它和“标记-清除”算法的不同之处就是它是**移动式**的。如果要移动存活对象，那么就会发生**Stop The World**：对象移动操作必须全程暂停用户应用程序才能进行

#### 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。它建立在2个分代假说之上：

1、弱分代假说：绝大多数对象都是朝生夕灭的

2、强分代假说：熬过多次垃圾收集过程的对象越难以消亡

**为了解决对象存在跨代引用而为内存回收带来很大的性能负担**，出现了第三条经验法则：

3、跨代引用假说：跨代引用相对于同代引用来说仅占极少数

## HotSpot的算法细节实现

### 根节点枚举

**迄今为止，所有收集器在根节点枚举这一步骤时都必须暂停用户线程**，也就是会面临“Stop The Word”的困扰。

当用户线程停下来后，并不需要一个不漏地检查完所有执行上下文（例如栈帧中的本地变量表）和全局引用（例如常量池或类静态属性）的引用位置，虚拟机应当是有办法直接得到哪些地方存在这对象引用的。Hotspot的解决方案就是使用一组称为**OopMap**的数据结构达到这个目的。

### 安全点

有了`OopMap`，Hotspot可以快速准确的完成GC Roots枚举。但这会带来另外一个问题：可能导致引用关系变化。

Hotspot不会为每条指令都生成OopMap，只是在**特定的位置**记录下栈里和寄存器里哪些位置是引用，而这个特定的位置就是**安全点**。

有了安全点，用户线程就不能在任意位置都能停顿下来开始执行垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。

如何在发生垃圾收集时让所有线程跑到最近的安全点，然后停顿下来？

* 抢先式中断
* 主动式中断：现在都采用的是这种方式

### 安全区域

安全点机制保证了程序**执行**时，在不太长的时间就会遇到可进入垃圾收集过程的安全点。但是，如果程序**不执行**，比如用户线程处于`sleep`或`blocked`状态，这时候线程就不能走到安全的地方去中断挂起自己，虚拟机也不会等到线程重新激活在分配处理器时间，这时候就必须引入**安全区域**来解决。

安全区域可以确保在某一段代码段之内，引用关系不会再发生变化，所以，在这个区域中任意地方开始垃圾收集都是安全的。**安全区间可以看作被扩展拉伸了的安全点**。

### 记忆集与卡表

在说这个之前，先来说下对象的跨代引用：

1、新生代->新生代，这种引用是不会有问题的

2、新生代->老年代，会造成多标、浮动垃圾，但对程序运行来说没有问题

3、老年代->老年代，也没问题

4、**老年代->新生代**，这就有问题了，比如新生代中的对象被GC了，那么就会产生空指针问题。

如何解决呢？就是通过记忆集

#### 记忆集

在分代理论收集中，为了解决对象跨代引用所带来的问题，垃圾收集器会在新生代中建立名为**记忆集**的数据结构，用来**缩减GC Roots**扫描范围的问题（避免把整个老年代加进GC Roots扫描范围）

记忆集是一种用于记录从**非收集区域**指向**收集区域**的**指针集合**的**抽象数据结构**。

#### 卡表

具体的实现就是**卡表**。

HotSpot中默认的卡表标记逻辑：

~~~cpp
CARD_TABLE [this address >> 9] = 0;
~~~

卡表的每一个元素都对应这其标识的内存区域中一块特定大小的内存块，叫做**卡页（Card Page）**。卡页大小都是2的N次幂字节数，如上面代码所示是2的9次幂，即512字节。

##### 脏页

一个卡页通常包含不止一个对象，只要卡页有一个（或多个）对象的字段存在跨代指针，就将**对应的卡表的数组元素的值标识为1，称为这个元素变脏，没有则标识为0**。那么在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块包含跨代指针，把他们加入GC Roots中一并扫描。

关于这部分内容，在G1收集器的时候还会详细讲解。

##### 存在2个问题

* 写屏障开销，不过这个开销于发生Minor GC时扫描整个老年代代价相比低很多，见下文
* 伪共享
  * 解决方法一：先检查卡表标记，只有当卡表没有被标记时才将其标记为变脏
  * 解决方法二：JDK7新增参数：`-XX:+UseCondCardMark`

### 写屏障

怎么解决卡表元素维护的问题？比如卡表何时变脏、谁来把它们变脏等。

#### 何时变脏

当其它区域中的对象引用了本区域对象时，对应的卡表元素就变脏、变脏时间点发生在引用类型字段赋值的那一刻。

#### 如何变脏

通过**写屏障**维护卡表状态，为所有赋值操作生成相应的指令，在赋值前的部分的写屏障叫做写前屏障，在复制后的则叫做写后屏障。类似于Spring的AOP。

~~~
1 写前屏障()
2 写操作
3 写后屏障()
~~~

### 并发的可达性分析

所有的垃圾回收算法都要经历标记阶段。如果GC线程在标记的时候暂停所有⽤户线程（STW），那就没三色标记什么事了。但是这样会有⼀个问题，⽤户线程需要等到GC线程标记完才能运⾏，给⽤户的感觉就是 很卡，⽤户体验很差。 现在主流的垃圾收集器都⽀持并发标记。什么是并发标记呢？就是标记的时候不暂停或少暂停⽤户线程， ⼀起运⾏。这势必会带来三个问题：多标、少标、漏标。垃圾收集器是如何解决这个问题的呢：三⾊标记 +读写屏障。

#### 三色标记

把遍历对象过程中遇到的对象，按照“是否访问过”这个条件标记成三种颜⾊： 

* 白色：尚未访问过，如果扫描完所有对象之后，最终为白色的为不可达对象，既垃圾对象。
* 黑色：本对象已访问过，⽽且本对象 引⽤到 的其他对象也全部访问过了。 
* 灰色：本对象已访问过，但是本对象 引⽤到 的其他对象尚未全部访问完。全部访问后，会转换为黑色。

#### 三个问题

##### 多标

GC线程已经标记了B，但是此时用户线程中的代码中断开了A对B的引用，而因为此时B已经被标记为了灰色，本轮GC不会被回收，这就是所谓的多标。多标会造成浮动垃圾，躲过本轮GC。对程序逻辑是没有影响的，下次收集清理掉就好。

![](https://z3.ax1x.com/2021/08/23/h92Pot.png)

##### 少标

并发标记开始后创建的对象，都视为黑色，本轮GC不清除。少标也会造成浮动垃圾

![](https://z3.ax1x.com/2021/08/23/h9RinJ.png)

##### 漏标

当GC把B标记完，准备标记B引用的对象，此时用户线程中将B对D的引用断开了，改为A对D的引用。但是A已经被标记为黑色，不会再对它扫描，而D还是白色，那么D就会被回收，**程序就会出错，比如发生空指针异常**

![](https://z3.ax1x.com/2021/08/23/h9R2gU.png)

#### 如何解决漏标

多标和少标是可以容忍的，无非就是产生了一些逃过本轮GC的浮动垃圾而已，下次清除就好了。但是漏标会产生程序错误，所以必须要解决。

我们分析下上面这张图是如何产生漏标的：

条件一：黑色对象重新引用了白色对象，即黑色对象的成员变量增加了新的引用。

条件二、灰色对象断开了白色对象的引用，即灰色对象的成员变量的引用发生了变化。

解决方法就是**破环这两个条件的任意一个即可**。

##### 写屏障+增量更新（IU）

增量更新破坏的是第一个条件：当黑色对象A插入了新的指向白色对象D的引用时，将就这个新插入的引用记录下来，等并发标记结束后，再将这些记录过的引用关系中的黑色对象A为根，重新扫描一次。可以理解为**黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了**。

##### 写屏障+原始快照（SATB）

原始快照破化的是第二个条件：当灰色对象B删除了指向B色对象D的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，再将这些记录过的引用关系中的灰色对象B为根，重新扫描一次。可以理解为：**无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索**。

##### 实际应用

CMS：写屏障+增量更新

G1：写屏障+原始快照

## 垃圾收集器

### CMS

## G1

## 内存分配与回收策略

#### 对象优先在Eden分配

大多数情况下，对象在新生代的Eden区分配。当`Eden`没有足够的空间时，将触发一次`Minor GC(Young Gc)`。

#### 大对象直接进入老年代

大对象：需要大量连续内存空间的java对象，比如字符串以及数组。

why？避免大对象分配内存时由于分配担保机制带来的复制而降低效率。

#### 长期存活的对象将进入老年代

#### 动态对象年龄判定

#### 空间担保机制

空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

## 亿级流量调优

这里以亿级流量秒杀电商系统为例：

1、如果每个用户平均访问20个商品详情页，那访客数约等于500w（一亿/20）

2、如果按转化率10%来算，那日均订单约等于50w（500w*10%）

3、如果30%的订单是在秒杀前两分钟完成的，那么每秒产生1200笔订单（50w*30%/120s）

4、订单⽀付⼜涉及到发起⽀付流程、物流、优惠券、推荐、积分等环节，导致产⽣⼤量对象，这⾥我们假 设整个⽀付流程⽣成的对象约等于20K，那每秒在Eden区⽣成的对象约等于20M（1200笔 * 20K） 

5、在⽣产环境中，订单模块还涉及到百万商家查询订单、改价、包邮、发货等其他操作，⼜会产⽣⼤量对 象，我们放⼤10倍，即每秒在Eden区⽣成的对象约等于200M（其实这⾥就是在⼤并发时刻可以考虑服务 降级的地⽅，架构其实就是取舍） 这⾥的假设数据都是⼤部分电商系统的通⽤概率，是有⼀定代表性的。

假设分配给堆的初始大小为8G（生产环境肯定比这个大），那么堆中各区域的内存布局如下：

![](https://z3.ax1x.com/2021/05/01/gVNvND.png)

依照上面的分析，每秒在Eden区生成的对象约等于200M，那么2.2G/200M/s=11s，也就是说11s内Eden区就会被占满。如果一个请求占3s，那么这时来了一个请求，就会产生3*200M=600M对象，这600M对象都还在使用，也就是说还能通过引用找到他们，那么他们就无法被回收，而这600MSurvivor区是放不下的，所以这时候会触发**空间担保机制，提前将Survivor放不下的对象也就是这600M提前转移到老年代去**。而老年代大小是5.4G，那么经历5.4G/600M=9次ygc后，就会触发一次fgc。而一次ygc触发时间是11s，那么9次ygc就是99s，也就是说**99s触发一次fgc**。

经过上面的分析，我们知道在堆内存8G的情况下，11s触发一次ygc，99s触发一次fgc，而正常的频率应该是

**5分钟一次ygc，一天一次fgc**。所以需要对当前系统调优。

调优怎么调呢？当前系统不要触发空间担保即可，言外之意就是Survivor的大小要大于600M，假设就以600M来算，根据Eden:Survivor=8:1，那么Eden就需要4800M，那么新生代大概需要4800+600*2=6G，而老年代是新生代的2倍，那么老年代就需要12G，整个堆就需要6+12=18G的大小。由于我们估算的比价大，所以单机有16G内存就足够了。当然，实际情况可能秒杀的流量更大，产生的对象也不一定和分析一致，所以还是要以系统实际情况为主。

调优的目的：避免OOM<--避免full gc<--避免young gc

单次gc时间在100ms以内（0.1s）