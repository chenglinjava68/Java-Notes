## 内存分配与回收策略

#### 对象优先在Eden分配

大多数情况下，对象在新生代的Eden区分配。当`Eden`没有足够的空间时，将触发一次`Minor GC(Young Gc)`。

#### 大对象直接进入老年代

大对象：需要大量连续内存空间的java对象，比如字符串以及数组。

why？避免大对象分配内存时由于分配担保机制带来的复制而降低效率。

#### 长期存活的对象将进入老年代

#### 动态对象年龄判定

#### 空间担保机制

空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

## 亿级流量调优

这里以亿级流量秒杀电商系统为例：

1、如果每个用户平均访问20个商品详情页，那访客数约等于500w（一亿/20）

2、如果按转化率10%来算，那日均订单约等于50w（500w*10%）

3、如果30%的订单是在秒杀前两分钟完成的，那么每秒产生1200笔订单（50w*30%/120s）

4、订单⽀付⼜涉及到发起⽀付流程、物流、优惠券、推荐、积分等环节，导致产⽣⼤量对象，这⾥我们假 设整个⽀付流程⽣成的对象约等于20K，那每秒在Eden区⽣成的对象约等于20M（1200笔 * 20K） 

5、在⽣产环境中，订单模块还涉及到百万商家查询订单、改价、包邮、发货等其他操作，⼜会产⽣⼤量对 象，我们放⼤10倍，即每秒在Eden区⽣成的对象约等于200M（其实这⾥就是在⼤并发时刻可以考虑服务 降级的地⽅，架构其实就是取舍） 这⾥的假设数据都是⼤部分电商系统的通⽤概率，是有⼀定代表性的。

假设分配给堆的初始大小为8G（生产环境肯定比这个大），那么堆中各区域的内存布局如下：

![](https://z3.ax1x.com/2021/05/01/gVNvND.png)

依照上面的分析，每秒在Eden区生成的对象约等于200M，那么2.2G/200M/s=11s，也就是说11s内Eden区就会被占满。如果一个请求占3s，那么这时来了一个请求，就会产生3*200M=600M对象，这600M对象都还在使用，也就是说还能通过引用找到他们，那么他们就无法被回收，而这600MSurvivor区是放不下的，所以这时候会触发**空间担保机制，提前将Survivor放不下的对象也就是这600M提前转移到老年代去**。而老年代大小是5.4G，那么经历5.4G/600M=9次ygc后，就会触发一次fgc。而一次ygc触发时间是11s，那么9次ygc就是99s，也就是说**99s触发一次fgc**。

经过上面的分析，我们知道在堆内存8G的情况下，11s触发一次ygc，99s触发一次fgc，而正常的频率应该是

**5分钟一次ygc，一天一次fgc**。所以需要对当前系统调优。

调优怎么调呢？当前系统不要触发空间担保即可，言外之意就是Survivor的大小要大于600M，假设就以600M来算，根据Eden:Survivor=8:1，那么Eden就需要4800M，那么新生代大概需要4800+600*2=6G，而老年代是新生代的2倍，那么老年代就需要12G，整个堆就需要6+12=18G的大小。由于我们估算的比价大，所以单机有16G内存就足够了。当然，实际情况可能秒杀的流量更大，产生的对象也不一定和分析一致，所以还是要以系统实际情况为主。

调优的目的：避免OOM<--避免full gc<--避免young gc

单次gc时间在100ms以内（0.1s）